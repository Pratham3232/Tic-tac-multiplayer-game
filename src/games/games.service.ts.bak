import { Injectable, NotFoundException, BadRequestException, ForbiddenException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Game, GameDocument, GameStatus, GameResult, PieceColor, Move } from '../schemas/game.schema';
import { User, UserDocument } from '../schemas/user.schema';
import { CreateGameDto, MakeMoveDto } from '../dto/game.dto';

@Injectable()
export class GamesService {
  constructor(
    @InjectModel(Game.name) private gameModel: Model<GameDocument>,
    @InjectModel(User.name) private userModel: Model<UserDocument>,
  ) {}

  async createGame(createGameDto: CreateGameDto, whitePlayerId: string): Promise<GameDocument> {
    const timeControlMinutes = createGameDto.timeControlMinutes || 10;
    const timeIncrementSeconds = createGameDto.timeIncrementSeconds || 0;
    
    const timeControlInitial = timeControlMinutes * 60 * 1000; // Convert to milliseconds
    const timeControlIncrement = timeIncrementSeconds * 1000; // Convert to milliseconds
    
    // Initialize empty tic-tac-toe board (9 cells, all null)
    const initialBoard = JSON.stringify(Array(9).fill(null));
    
    const game = new this.gameModel({
      whitePlayer: whitePlayerId,
      timeControlInitial,
      timeControlIncrement,
      whiteTimeRemaining: timeControlInitial,
      blackTimeRemaining: timeControlInitial,
      currentPosition: initialBoard,
    });
    
    return game.save();
  }

  async joinGame(gameId: string, blackPlayerId: string): Promise<GameDocument> {
    const game = await this.gameModel.findById(gameId).exec();
    
    if (!game) {
      throw new NotFoundException('Game not found');
    }
    
    if (game.status !== GameStatus.WAITING) {
      throw new BadRequestException('Game is not available to join');
    }
    
    if (game.whitePlayer.toString() === blackPlayerId) {
      throw new BadRequestException('You cannot play against yourself');
    }
    
    if (game.blackPlayer) {
      throw new BadRequestException('Game is already full');
    }
    
    game.blackPlayer = blackPlayerId as any;
    game.status = GameStatus.IN_PROGRESS;
    game.startedAt = new Date();
    console.log('ðŸŽ® makeMove called:', { gameId, playerId, moveData: makeMoveDto });
    
    return game.save();
  }

  async makeMove(gameId: string, makeMoveDto: any, playerId: string): Promise<GameDocument> {
    const game = await this.gameModel.findById(gameId).exec();
    
    if (!game) {
      throw new NotFoundException('Game not found');
    }
    
    if (game.status !== GameStatus.IN_PROGRESS) {
      throw new BadRequestException('Game is not in progress');
    }
    
    // Determine player's color
    const playerColor = game.whitePlayer.toString() === playerId ? PieceColor.WHITE : PieceColor.BLACK;
    
    if (game.blackPlayer?.toString() !== playerId && game.whitePlayer.toString() !== playerId) {
      throw new ForbiddenException('You are not a player in this game');
    }
    
    if (game.currentTurn !== playerColor) {
      throw new BadRequestException('It is not your turn');
    }
    
    // Parse current board state
    let board: (string | null)[];
    try {
      board = JSON.parse(game.currentPosition);
    } catch (error) {
      board = Array(9).fill(null);
    }
    
    // Get the cell index from the move (using 'to' field as the index)
    const cellIndex = parseInt(makeMoveDto.to);
    
    if (isNaN(cellIndex) || cellIndex < 0 || cellIndex > 8) {
      throw new BadRequestException('Invalid cell index');
    }
    
    if (board[cellIndex]) {
      throw new BadRequestException('Cell is already occupied');
    }
    
    // Determine symbol (X for white/first player, O for black/second player)
    const symbol = playerColor === PieceColor.WHITE ? 'X' : 'O';
    
    // Place the symbol on the board
    board[cellIndex] = symbol;
    
    // Create the move record
    const move: Move = {
      from: makeMoveDto.from,
      to: makeMoveDto.to,
      piece: symbol as any,
      color: playerColor,
      algebraicNotation: `${symbol} â†’ Cell ${cellIndex + 1}`,
      timestamp: new Date(),
      isCheck: false,
      isCheckmate: false,
      isCastling: false,
      isEnPassant: false,
    };
    
    // Add move to game
    game.moves.push(move);
    
    // Update board position
    game.currentPosition = JSON.stringify(board);
    
    // Check for win condition
    const winResult = this.checkWin(board);
    if (winResult.winner) {
      game.status = GameStatus.COMPLETED;
      game.result = winResult.winner === 'X' ? GameResult.WHITE_WINS : GameResult.BLACK_WINS;
      game.winner = playerId as any;
      game.endedAt = new Date();
    } else if (winResult.draw) {
      game.status = GameStatus.COMPLETED;
      game.result = GameResult.DRAW;
      game.endedAt = new Date();
    } else {
      // Switch turns
      game.currentTurn = game.currentTurn === PieceColor.WHITE ? PieceColor.BLACK : PieceColor.WHITE;
    }
    
    return game.save();
  }

  private checkWin(board: (string | null)[]): { winner: string | null; draw: boolean } {
    // Check all winning combinations
    const winPatterns = [
      [0, 1, 2], // Top row
      [3, 4, 5], // Middle row
      [6, 7, 8], // Bottom row
      [0, 3, 6], // Left column
      [1, 4, 7], // Middle column
      [2, 5, 8], // Right column
      [0, 4, 8], // Diagonal \
      [2, 4, 6], // Diagonal /
    ];
    
    for (const pattern of winPatterns) {
      const [a, b, c] = pattern;
      if (board[a] && board[a] === board[b] && board[a] === board[c]) {
        return { winner: board[a], draw: false };
      }
    }
    
    // Check for draw (all cells filled, no winner)
    const isFull = board.every(cell => cell !== null);
    if (isFull) {
      return { winner: null, draw: true };
    }
    
    return { winner: null, draw: false };
  }

  async getGame(gameId: string): Promise<GameDocument> {
    const game = await this.gameModel
      .findById(gameId)
      .populate('whitePlayer', 'username rating')
      .populate('blackPlayer', 'username rating')
      .exec();
    
    if (!game) {
      throw new NotFoundException('Game not found');
    }
    
    return game;
  }

  async getActiveGames(): Promise<GameDocument[]> {
    return this.gameModel
      .find({ status: GameStatus.WAITING })
      .populate('whitePlayer', 'username rating')
      .sort({ createdAt: -1 })
      .limit(20)
      .exec();
  }

  async getUserGames(userId: string, limit = 10): Promise<GameDocument[]> {
    return this.gameModel
      .find({
        $or: [
          { whitePlayer: userId },
          { blackPlayer: userId },
        ],
      })
      .populate('whitePlayer', 'username rating')
      .populate('blackPlayer', 'username rating')
      .sort({ createdAt: -1 })
      .limit(limit)
      .exec();
  }

  async abandonGame(gameId: string, playerId: string): Promise<GameDocument> {
    const game = await this.gameModel.findById(gameId).exec();
    
    if (!game) {
      throw new NotFoundException('Game not found');
    }
    
    if (game.whitePlayer.toString() !== playerId && game.blackPlayer?.toString() !== playerId) {
      throw new ForbiddenException('You are not a player in this game');
    }
    
    if (game.status === GameStatus.COMPLETED) {
      throw new BadRequestException('Game is already completed');
    }
    
    game.status = GameStatus.ABANDONED;
    game.endedAt = new Date();
    
    // Determine winner (the other player)
    if (game.whitePlayer.toString() === playerId) {
      game.result = GameResult.BLACK_WINS;
      game.winner = game.blackPlayer as any;
    } else {
      game.result = GameResult.WHITE_WINS;
      game.winner = game.whitePlayer;
    }
    
    return game.save();
  }
}
